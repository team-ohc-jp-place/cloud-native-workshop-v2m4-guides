= Lab1 - 高性能なキャッシュ可能なサービスの構築
:experimental:

このラボでは、5つのマイクロサービスを Cloud Native アプリケーションアーキテクチャで開発します。これらの Cloud Native アプリケーションは、*PostgreSQL* や *MongoDB* などの複数のデータソースとのトランザクションを持つことになります。特に、*Quarkus Extensions* を利用して、簡単にデータソースを設定する方法を学びます。最終的には、*Cache(Data Grid)サーバ* との連携により、ショッピングカートサービスのデータトランザクションのパフォーマンスを最適化し、エンドユーザーの満足度を向上させます。また、*oc* コマンドラインツールを使ってOpenShift 4上にアプリケーションを簡単にデプロイすることができます。

=== このラボのゴール

目標は、*Red Hat Runtimes* 上で高度なクラウドネイティブアプリケーションを開発し、_シングルサインオンアクセス管理_ と _分散キャッシュ管理_ を含む *OpenShift 4* 上でデプロイすることです。このラボの後には、以下のようなものを完成させる必要があります。

image::lab1-goal.png[goal, 700]

=== 1. inventory-service のデプロイ

_Inventory Service_ は、小売商品の在庫と在庫状況のデータを提供します。inventory-service がどのように動作し、*Quarkus* Javaランタイム上に構築されているかを簡単に見てみましょう。_CodeReady Works_  Web IDE の _/projects_ に移動し、*inventory-service* ディレクトリを展開してください。

image::codeready-workspace-inventory-project.png[inventory_service, 700]

コードは驚くほどシンプルですが、内部ではこれを使用しています :

* REST エンドポイントを公開するための *RESTEasy*
* データベースの CRUD 操作を行うための *Hibernate ORM* with Panache
* *Maven* Java project structure

_Hibernate ORM_ は事実上の JPA 実装であり、Object Relational Mapper の全幅を提供します。複雑なマッピングを可能にしますが、単純でマッピングを退屈にするものではありません。Hibernate ORM with Panache は、Quarkus で書くのが楽しくなるように、エンティティを些細なものにすることに焦点を当てています。

以下のように `src/main/java/com/redhat/cloudnative/` の `Inventory.java` を開くと、Quarkus の拡張機能( https://quarkus.io/guides/hibernate-orm-panache-guide[Hibernate ORM with Panache^] を使っていかに簡単にドメインモデルを作成できるかがわかると思います。)

[source,java]
----
@Entity
@Cacheable
public class Inventory extends PanacheEntity {

    public String itemId;
    public String location;
    public int quantity;
    public String link;

    public Inventory() {

    }

}
----

* エンティティの中で `PanacheEntity` を拡張することで、自動生成される ID フィールドが得られます。カスタムの ID 戦略が必要な場合は、代わりに `PanacheEntityBase` を拡張して ID を自分で処理することができます。
* Public fields を使うことで、意味のないゲッターやセッター(単にフィールドを取得したり設定したりするだけのもの)が不要になります。 `Inventory.getLocation()` の実装を書かずに、 `Inventory.location` のようなフィールドを参照するだけです。Panache は、未実装のゲッターやセッターを自動生成します。もしくはフィールドに直接アクセスしたときに呼び出される get/set 以上の機能を持つ独自の ゲッター/セッター を開発することもできます。

`PanacheEntity` スーパークラスには多くの便利な静的メソッドがあり、派生エンティティクラスに独自のメソッドを追加することができます。伝統的なオブジェクト指向プログラミングのように、カスタムクエリを可能な限りエンティティの近くに、理想的にはエンティティ定義自体の中に配置することが自然であり、推奨されています。ユーザーは、 `Inventory.` と入力するだけで、エンティティ Inventory を使い始めることができ、一箇所ですべての操作を完了させることができます。

エンティティに `@Cacheable` をアノテーションすると、コレクションと他のエンティティとの関係を除いて、すべてのフィールド値がキャッシュされます。これは、データベースを照会することなくエンティティをロードできることを意味しますが、ロードされたエンティティがデータベースの最近の変更を反映していない可能性があることを意味するので注意が必要です。

次に、inventoryサービスがどのようにして Quarkus 上で _RESTful API_ を公開しているかを調べてみましょう。 `src/main/java/com/redhat/cloudnative/` の `InventoryResource.java` を開くと、以下のようなコードスニペットが表示されます。

REST サービスは二つのエンドポイントを定義します :

* これは `HTTP GET` でアクセスできる `/api/inventory` であり、これはすべての既知の製品インベントリエンティティを JSON として返します。
* 例えば `/inventory/329199` のように、`HTTP GET` でアクセスできる `/api/inventory/<itemId>` は、最後のパスパラメータにインベントリの状態を確認したい場所を指定します。

image::inventoryResource.png[inventory_service, 700]

*開発中では* , src/main/resources/application.properties`で定義されているように、ローカルのテストに _in-memory H2 database_ を使用するように設定します :

[source,none]
----
%dev.quarkus.datasource.url=jdbc:h2:file://projects/database.db
%dev.quarkus.datasource.driver=org.h2.Driver
%dev.quarkus.datasource.username=inventory
%dev.quarkus.datasource.password=mysecretpassword
%dev.quarkus.datasource.max-size=8
%dev.quarkus.datasource.min-size=2
%dev.quarkus.hibernate-orm.database.generation=drop-and-create
%dev.quarkus.hibernate-orm.log.sql=false
----

CodeReady Workspaces Terminal経由で `maven plugin command` を使ってローカルでインベントリアプリケーションを実行してみましょう:

[source,sh,role="copypaste"]
----
mvn quarkus:dev -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/inventory-service
----

以下で終わるログ出力が表示されるはずです :

[source,console]
----
2020-03-19 00:55:12,598 INFO  [io.agr.pool] (main) Datasource '<default>': Initial size smaller than min. Connections will be created when necessary
2020-03-19 00:55:12,887 INFO  [io.quarkus] (main) inventory 1.0-SNAPSHOT (running on Quarkus xx.xx.xx) started in 3.166s. Listening on: http://0.0.0.0:8080
2020-03-19 00:55:12,890 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2020-03-19 00:55:12,890 INFO  [io.quarkus] (main) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, jdbc-h2, narayana-jta, resteasy, resteasy-jsonb, smallrye-health]
----

CodeReady は、Quarkus アプリがポート `5005` (デバッグ用)と `8080` (ウェブリクエスト用)を開いていることも検出します。ポート 5005 は開かず、プロンプトが表示されたらポート `8080` を開いてください。

ログ出力の束が表示され、Theia のポップアップにはローカルアプリケーションのエンドポイントが表示されているはずです。`Open Link` クリックすると、左側に *Coolstore Inventory* ページが表示されます。ポップアップウィンドウを `Close` してください。

image::open-port.png[Inventory RESTful Service, 700]

CodeReadyでインベントリのWebフロントエンドを直接見ることができるはずです( _reload_ アイコンをクリックする必要があるかもしれません) :

image::inventory-codeready.png[Inventory RESTful Service, 700]

新しい *CodeReady Workspaces* ターミナルを開きます。

image::codeready-workspace-terminal.png[Inventory RESTful Service, 700]

以下の CURL コマンドをしよすいて RESTful endpoint を呼び出します.

[source,sh,role="copypaste"]
----
curl http://localhost:8080/api/inventory | jq
----

出力は以下のようになります :

[source,json]
----
  ...
  {
    "id": 7,
    "itemId": "444435",
    "link": "http://maps.google.com/?q=Paris",
    "location": "Paris",
    "quantity": 600
  },
  {
    "id": 8,
    "itemId": "444437",
    "link": "http://maps.google.com/?q=Tokyo",
    "location": "Tokyo",
    "quantity": 230
  }
----

実行中のQuarkus開発を kbd:[CTRL+C] (Mac OSの場合はkbd:[Command+C] )で終了させてください。

*本番* では、インベントリサービスは OpenShift クラスタ上の _PostgeSQL_ に接続します。

今回は _Quarkus extension_ を使用して、*PostgreSQL JDBC Driver* を追加します。CodeReady Workspaces Terminal に戻り、以下の maven プラグインを実行します :

[source,sh,role="copypaste"]
----
mvn -q quarkus:add-extension -Dextensions="jdbc-postgresql" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/inventory-service
----

以下の出力を確認できます :

[source,console]
----
✅ Extension io.quarkus:quarkus-jdbc-postgresql has been installed
----

まず、 {{ CONSOLE_URL }}[OpenShift web console^] で新規ブラウザを開きます :

image::openshift_login.png[openshift_login, 700]

Login using:

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

アクセスできるプロジェクトのリストが表示されます :

image::openshift_landing.png[openshift_landing, 700]

[NOTE]
====
ランディングページに表示されるプロジェクトは、今日実行するラボによって異なります。`Service Mesh and Identity` を開発する場合は、上記のようにあらかじめ作成されたプロジェクトが表示されます。
====

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] を開きます。

私たちの生産インベントリマイクロサービスは、インベントリデータを格納するために外部データベース (PostgreSQL) を使用します。まず、PostgreSQL の新しいインスタンスを配置します。左側の *{{ USER_ID }}-cloudnativeapps* プロジェクト概要の _Database_ ボックスで *+Add* をクリックします :

image::db.png[db, 700]

検索ボックスに `postgres` と入力し、*PostgreSQL (ephemeral)* をクリックします:

image::db-postgres.png[db, 700]

*Instantiate Template* して以下の項目を入力してください :

* *Namespace*: _最初のネームスペースに `{{ USER_ID }}-cloudnativeapps` を選択してください。二つ目のネームスペースは `openshift` のまま残してください _
* *Database Service Name*: `inventory-database`
* *PostgreSQL Connection Username*: `inventory`
* *PostgreSQL Connection Password*: `mysecretpassword`
* *PostgreSQL Database Name*: `inventory`

image::db-postgres-inventory-values.png[db, 700]

これでデータベースが新しいプロジェクトにデプロイされます。 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] をクリックすると表示されます :

image::inventory-database-deployment.png[inventory_db_deployments, 700]


CodeReady Workspace は Kubernetes クラスタ上で実行されていますが、デフォルトの制限付き _Service Account_ で実行されているため、ほとんどのリソースタイプを作成することができません。他のモジュールを完了している場合は、おそらくすでにログインしていると思いますが、もう一度ログインしてみましょう: *Login to OpenShift* をクリックして、与えられた資格情報を入力します :

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

image::cmd-login.png[login,700]

このようなものが表示されるはずです（プロジェクト名が異なる場合があります）:

[source,none]
----
Login successful.

You have access to the following projects and can switch between them with 'oc project <projectname>':

  * {{ USER_ID }}-bookinfo
    {{ USER_ID }}-catalog
    {{ USER_ID }}-cloudnative-pipeline
    {{ USER_ID }}-cloudnativeapps
    {{ USER_ID }}-inventory
    {{ USER_ID }}-istio-system

Using project "{{ USER_ID }}-bookinfo".
Welcome! See 'oc help' to get started.
----

[NOTE]
====
*Login to OpenShift* でログインした後は、通常のターミナルとして使用できなくなります。ターミナルのウィンドウは閉じることができます。後からさらに端末を開いてもログインしたままになります。
====

では、アプリケーション自体をデプロイしてみましょう。以下のコマンドを実行すると、OpenShift 拡張機能を使用してビルドとデプロイが行われます :

[source,sh,role="copypaste"]
----
oc project {{ USER_ID }}-cloudnativeapps && \
mvn clean compile package -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/inventory-service
----

出力は `BUILD SUCCESS` で終わるべきです。

最後に、実際にロールアウトが完了したことを確認してください :

[source,sh,role="copypaste"]
----
oc rollout status -w dc/inventory
----

続ける前に、そのコマンドが *replication controller _inventory-1_ successfully rolled out* を報告するのを待ちます。

そして、アイテムには適切なアイコンでラベルを貼ります :

[source,sh,role="copypaste"]
----
oc label dc/inventory app.kubernetes.io/part-of=inventory --overwrite && \
oc label dc/inventory-database app.kubernetes.io/part-of=inventory app.openshift.io/runtime=postgresql --overwrite && \
oc annotate dc/inventory app.openshift.io/connects-to=inventory-database --overwrite && \
oc annotate dc/inventory app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] に戻り, デプロイが完了していることを確認します(紺色の丸) :

image::inventory_topology.png[inventory, 700]

上図のように小さな矢印のアイコンをクリックすると、在庫が表示されます :

image::inventory_topology_openurl.png[inventory, 700]

これで `Inventory` サービスが OpenShift にデプロイされました。OpenShift Console の Project Status でも、Postgres データベースポッドと一緒に1つのポッドでシングルレプリカが実行されているのが確認できます。

=== 2. カタログサービスのデプロイ

_カタログサービス_ は、小売商品の商品と価格を提供します。カタログサービスがどのように動作し、*Spring Boot* Javaランタイム上に構築されているかを簡単に見てみましょう。_CodeReady Workspaces_ の _CodeReady Workspaces_ Web IDEの _/projects_ に移動して、 *catalog-service* ディレクトリを展開します。

image::codeready-workspace-catalog-project.png[catalog, 700]

まず、Git サーバーからプロジェクトをインポートした時点で、すべての関数が構築されているので、データを取得するためのカタログアプリケーションは実装しません。OpenShift クラスタにデプロイする前に、この Spring Boot アプリケーションを見ておくべきことがいくつかあります。

このカタログサービスは、Spring Boot プロジェクトが通常使用するデフォルトの BOM (部品表) を使用していません。代わりに、Red Hat が http://snowdrop.me/[Snowdrop^] プロジェクトの一部として提供している BOM を使用しています。

[source,xml]
----
<dependency>
    <groupId>dev.snowdrop</groupId>
    <artifactId>snowdrop-dependencies</artifactId>
    <version>2.2.10.Final-redhat-00001</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
----

image::catalog-pom.png[catalog, 700]

また、catalog-service は、先ほど展開したインベントリサービスをRESTを使って呼び出して、インベントリの状態を取得し、インクルードしています。
レスポンスの中にそれが表示されます。プロジェクトエクスプローラで `src/main/java/com/redhat/cloudnative/service` ディレクトリの `CatalogService.java` を開き、`read()メソッド` と readAll() メソッドがどのように動作するかを確認してください :

image::catalog-service-codes.png[catalog, 700]

以下のコマンドを使用してプロジェクトをビルドし、CodeReady Workspaces Terminal を介してデプロイするために maven プラグインを使用します :

[source,sh,role="copypaste"]
----
mvn clean package spring-boot:repackage -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/catalog-service
----

ビルドとデプロイには 1～2 分かかる場合があります。完了するのを待ちましょう。ビルド出力の最後に `BUILD SUCCESS` が表示されるはずです。

私たちの `production` カタログマイクロサービスは、インベントリデータを格納するために外部データベース (PostgreSQL) を使用します。 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] にアクセスしてください。

プロジェクト概要の _Database_ ボックスの左側にある *+Add* をクリックします :

image::db.png[db, 700]

検索ボックスに `postgres` と入力し、*PostgreSQL (ephemeral)* をクリックします :

image::db-postgres.png[db, 700]

*Instantiate Template* をクリックして、以下の項目を入力してください: 

* *Namespace*: _ 最初のネームスペースに `{{ USER_ID }}-cloudnativeapps` を指定してください。ふたつ目は `openshift` のままにしておきます。 _
* *Database Service Name*: `catalog-database`
* *PostgreSQL Connection Username*: `catalog`
* *PostgreSQL Connection Password*: `mysecretpassword`
* *PostgreSQL Database Name*: `catalog`

image::db-catalog-postgres-fields.png[db, 700]

これでデータベースがカタログプロジェクトにデプロイされます。 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] をクリックすると表示されます。

OpenShiftでOpenJDKベースのコンテナイメージを使用してアプリケーションのビルド構成を作成します :

[source, properties, role="copypaste"]
----
oc new-build registry.access.redhat.com/ubi8/openjdk-11 --binary --name=catalog -l app=catalog
----

開始して、数分程度で完成するビルドを見てください :

[source,sh,role="copypaste"]
----
oc start-build catalog --from-file=$CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/catalog-service/target/catalog-1.0.0-SNAPSHOT.jar --follow
----

ビルドが完了したら、OpenShift アプリケーションとしてデプロイし、スプリングプロファイルをオーバーライドして _production_ の値を使用します。また、見栄えを良くするためにいくつかのラベルを与えます。このコマンドを実行します :

[source,sh,role="copypaste"]
----
oc new-app catalog --as-deployment-config -e JAVA_OPTS_APPEND='-Dspring.profiles.active=openshift' && oc expose service catalog && \
oc label dc/catalog app.kubernetes.io/part-of=catalog app.openshift.io/runtime=spring --overwrite && \
oc label dc/catalog-database app.kubernetes.io/part-of=catalog app.openshift.io/runtime=postgresql --overwrite && \
oc annotate dc/catalog app.openshift.io/connects-to=inventory,catalog-database --overwrite && \
oc annotate dc/catalog app.openshift.io/vcs-uri=https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m4-labs.git --overwrite && \
oc annotate dc/catalog app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

最後に、実際にロールアウトが完了していることを確認します。カタログは {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] にアクセスして、青い丸が表示されていることを確認してください!

image::inventory-catalog-topology.png[catalog, 700]

そして、 http://catalog-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN }}[Catalog Web frontend^] にアクセスして、期待される在庫量を取得していることを確認してください（not `-1`）:

image::catalog.png[catalog, 700]

これで `Catalog` サービスが OpenShift にデプロイされました。OpenShift Console のプロジェクトステータスでも、カタログ、カタログデータベース、インベントリ、インベントリデータベースの4つのポッドが稼働しているのが確認できます。

=== 3. ショッピングカートサービスの開発・展開

これまでに、Coolstore アプリケーションに必要な要素のいくつかを配備しました。しかし、カートのないオンライン・ショップでは、チェックアウトの経験がありません。このセクションでは、ショッピングカートを実装します。マイクロサービスの世界では、これを *cart-service* と呼び、Javaアーティファクト/レポを *cartサービス* と呼びます。

cart-servcie は RESTful で、Red Hat の Distributed _Data Grid_ テクノロジーを使用して Quarkus で構築されています。すべてのショッピングカートのデータを保存し、それぞれに一意の ID を割り当てます。これを行うには、Quarkus の _Infinispan_ クライアント_を使用します（_Infinispan_は、Red Hat Data Gridがベースになっているアップストリームプロジェクトの名前です）。ショッピングカートは、Quarkus REST クライアントを介して呼び出しを行い、カタログ内のすべてのアイテムを取得します。最終的に、ショッピングカートはまた、ユーザーがチェックアウトしているときに、注文ごとに_Kafka_にメッセージをプッシュします。そのために、Quarkus Kafkaクライアントを使用します。

ショッピングカートとは何ですか？ショッピングカートはショッピングアイテムのリストを持っています。各アイテムには _quantity_ と、割引やプロモーションの詳細などの他のフィールドがあります。これらについては、モデルを見るときに詳しく見ていきましょう。

このラボでは、CodeReady ワークスペースを使用します。ワークスペースで以下のプロジェクトを開いていることを確認してください。ここでは、カートサービスがどのように動作し、_Quarkus_ Javaランタイム上に構築されているかを簡単に説明します。CodeReady Workspaces の _Explorer_ に移動し、*cart-service* ディレクトリを展開します。

image::codeready-workspace-cart-project.png[cart, 700]

Red Hat Distributed _Data Grid_ を使用して、すべてのユーザーのカートをキャッシュします。

クラスタ内の *cacheサービス* の簡単なバージョンを作成してみましょう。CodeReady ワークスペースでターミナルを開き、以下のコマンドを実行します :

[source,sh,role="copypaste"]
----
oc new-app --as-deployment-config jboss/infinispan-server:10.0.0.Beta3 --name=datagrid-service
----

これにより、ショッピングカートを格納するためのデータグリッドサーバのインスタンスが1つ作成されます。

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[トポロジービュー^] をクリックすると表示されます。

これでキャッシュサービス、別名データグリッドサービスがデプロイされました。私たちは、カート内のすべてのものがこの高速なキャッシュに保存されていることを確認したいと思っています。これは、ブラックフライデーに毎秒数百万人のユーザーがいるときに役立ちます。

次のことを行う必要があります :

* データのモデル化をおこなう
* データの保存方法を選択
* データのマーシャルを作成する
* キャッシュ接続をサービスに注入する

この選択をより簡単にしました。デフォルトのシリアライズは *protobuf* をベースにしたライブラリを使用して行われます。protobuf スキーマと各ユーザタイプ用のマーシャラーを定義する必要があります。

`cart-service/src/main/resources/META-INF` の `cart.proto` ファイルを見てみましょう :

[source,java]
----
package coolstore;

message ShoppingCart {
  required double cartItemTotal = 1;
  required double cartItemPromoSavings = 2;
  required double shippingTotal = 3;
  required double shippingPromoSavings = 4;
  required double cartTotal = 5;
  required string cartId = 6;

  repeated ShoppingCartItem shoppingCartItemList = 7; // <1>
}

message ShoppingCartItem {
  required double price = 1;
  required int32 quantity = 2;
  required double promoSavings = 3;
  required Product product = 4; // <2>
}

// TODO ADD Product
message Promotion {
  required string itemId = 1;
  required double percentOff = 2;
}
----
<1> つまり、`ShoppingCart` は `ShoppingCartItem` のリスト (`repeated`) を持っていることになります。
<2> 各 `ShoppingCartItem` は `Product` を持ちます。

しかし、まだ `Product` を定義していません。このコードを `//TODO ADD Product` マーカーの下に追加します。

[source,java,role="copypaste"]
----
message Product {
  required string itemId = 1;
  required string name = 2;
  required string desc = 3;
  required double price = 4;
}
----

*これで、プロトモデルに製品が定義されました。また、このモデルが POJO* (Plain Old Java Object)としても存在することを確認する必要があります。そうすれば、*RESTエンドポイント* や *Cache* が直接データをシリアライズしてデシリアライズすることができます。

次に、`cart-service/src/main/java/com/redhat/cloudnative/model` 内の `Product.java` を開く : 

[source,java]
----
    private String itemId;
    private String name;
    private String desc;
    private double price;
----

実体が私たちのプロトファイルと一致していることに注目してください。残りの部分、またはゲッターとセッターなので、それらにデータを読み書きすることができます。

先に進み、Productクラス用の *Marshaller* を作成してみましょう。これは、キャッシュへの読み書きを正確に行います。

`com.redhat.cloudnative.model` の中に `ProductMarshaller.java` という名前の Java クラスを新規作成し、以下のコードをファイルにコピーする。

[source,java,role="copypaste"]
----
package com.redhat.cloudnative.model;

import org.infinispan.protostream.MessageMarshaller;

import java.io.IOException;

public class ProductMarshaller implements MessageMarshaller<Product> {

    /*
     * Proto file specimen
     * message Product {
     * required string itemId = 1;
     * required string name = 2;
     * required string desc = 3;
     * required double price = 4;
     * }
     */

    @Override
    public Product readFrom(ProtoStreamReader reader) throws IOException {
        String itemId = reader.readString("itemId");
        String name = reader.readString("name");
        String desc = reader.readString("desc");
        double price = reader.readDouble("price");

        return new Product(itemId, name, desc, price);
    }

    @Override
    public void writeTo(ProtoStreamWriter writer, Product product) throws IOException {
        writer.writeString("itemId", product.getItemId());
        writer.writeString("name", product.getName());
        writer.writeString("desc", product.getDesc());
        writer.writeDouble("price", product.getPrice());
    }

    @Override
    public Class<? extends Product> getJavaClass() {
        return Product.class;
    }

    @Override
    public String getTypeName() {
        return "coolstore.Product";
    }

}
----

これで、*ProtoStream* からの読み込みと *Write* ができるようになりました。そして、これはキャッシュに直接実行されます。他のモデルクラスとマッシャーは既に作成済みです。

それでは、*RemoteCache* を設定してみましょう。`com.redhat.cloudnative` ディレクトリ/パッケージ内の `Producers.java` ファイルを開きます。

プロデューサを使用して RemoteCache を確実にインスタンス化します。getCache と getConfigBuilder というメソッドを作成します。

* getConfigBuilder: 基本的なキャッシュ設定を設定します
* getCache、マーシャラーとプロトファイルをセットアップします
* その他の設定プロパティは実行時に注入されます

このコードを `// TODO Add getCache` と `// TODO add getConfigBuilder` マーカーの下に追加します :

[source,java,role="copypaste"]
----
    @Produces
    RemoteCache<String, ShoppingCart> getCache() throws IOException {

        RemoteCacheManager manager = new RemoteCacheManager(getConfigBuilder().build());

        SerializationContext serCtx = ProtoStreamMarshaller.getSerializationContext(manager);
        FileDescriptorSource fds = new FileDescriptorSource();
        fds.addProtoFiles("META-INF/cart.proto");
        serCtx.registerProtoFiles(fds);
        serCtx.registerMarshaller(new ShoppingCartMarshaller());
        serCtx.registerMarshaller(new ShoppingCartItemMarshaller());
        serCtx.registerMarshaller(new ProductMarshaller());
        serCtx.registerMarshaller(new PromotionMarhsaller());
        return manager.getCache();
    }

    protected ConfigurationBuilder getConfigBuilder() {
        ConfigurationBuilder cfg = null;
        cfg = new ConfigurationBuilder().addServer()
                .host(dgHost)
                .port(dgPort)
                .marshaller(new ProtoStreamMarshaller())
                .clientIntelligence(ClientIntelligence.BASIC);

        return cfg;

    }
----

これで、キャッシュを使用するためのすべてのビルディングブロックの準備が整いました。キャッシュを使い始めましょう。

次に、サービスにキャッシュを注入することを確認する必要があります。`com.redhat.cloudnative.service.ShoppingCartServiceImpl` を開き、`// TODO Inject RemoteCache` マーカーに追加します :

[source,java,role="copypaste"]
----
    @Inject
    @Remote("default")
    RemoteCache<String, ShoppingCart> carts;
----

カートは非常にシンプルです。ブラウザからの情報、つまり *Angular App* からの情報はすべて _/api/cart_ エンドポイントで _JSON_ を経由しています :

* `GET /{cartId}` はカート内のアイテムを取得
* `POST /{cartId}/{itemId}/{quantity}` はカートにアイテムを追加
* `DELETE /{cartId}/{itemId}/{quantity}` はカートからアイテムを削除
* `POST /checkout/{cartId}` はアイテムを削除し、チェックアウト手続きを呼び出します。

Quarkus を使った方法を見てみましょう。私たちの *cart-service* プロジェクトとメインパッケージの `com.redhat.cloudnative` には `CartResource` があります。getCart メソッドを見てみましょう。

`// TODO ADD getCart method` マーカーの箇所で次のメソッドを追加します。:

[source,java,role="copypaste"]
----
    public ShoppingCart getCart(@PathParam("cartId") String cartId) {
        return shoppingCartService.getShoppingCart(cartId);
    }
----

上のコードは `ShoppingCartService` を利用しているが、これは依存性インジェクションによって `CartResource` に注入される。この `ShoppingCartService` は `cartId` をパラメータとして受け取り、関連するショッピングカートを返す。これで完璧ですが、エンドポイントである CartResource が応答するためには、いくつかのことを定義する必要があります :

* HTTPRequest のタイプ
* 受信できるデータの種類
* 解決するパス

以下のコードを `getCart` メソッドの先頭に追加します

[source,java,role="copypaste"]
----
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/{cartId}")
    @Operation(summary = "get the contents of cart by cartId")
----

これで、メソッドが GET リクエストに準拠し、*プレーンテキスト* でデータを受け付けることに成功しました。パスは `/api/cart/{cartId}` になります。最後に、いくつかのドキュメントを作成するために `@Operation` アノテーションを追加します。

この機会に他のメソッドのいくつかを見てみましょう。`@POST` と `@DELETE`、そしてそれらが従うパスを見つけることができるでしょう。これは、アプリケーションのためのシンプルなエンドポイントを構築する方法です。

[NOTE]
====
他にも *//TODO* マーカーやコメントアウトしたコードは後ほど使用します。今のところ、それらは放っておいてください。
====

Quarkus では、まともなデフォルト設定とユーザーが提供する設定に基づいて OpenShift リソースを自動的に生成する機能も提供しています。OpenShift 拡張は、実際には https://quarkus.io/guides/deploying-to-kubernetes[kubernetes] と https://quarkus.io/guides/container-image#s2i[container-image-s2i] の拡張をデフォルトでまとめたラッパー拡張であり、ユーザーが OpenShift 上で Quarkus を使い始めやすいようにしています。

CodeReady Workspaces Terminal 経由で _openshift_ 拡張機能を追加します :

[source,sh,role="copypaste"]
----
mvn -q quarkus:add-extension -Dextensions="openshift" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/cart-service
----

以下が確認できます:

✅ Extension io.quarkus:quarkus-openshift has been installed

Quarkusでは、_configuration profiles_ という概念をサポートしています。これにより、同じファイル内に複数の設定を持つことができ、 _プロファイル名_ を使用してその中から選択することができます。

_src/main/resources/application.properties_ の `# TODO: Add for OpenShift extension` マーカーに以下の変数を `追加` してみましょう。

[source,shell,role="copypaste"]
----
quarkus.kubernetes-client.trust-certs=true<1>
quarkus.container-image.build=true<2>
quarkus.kubernetes.deploy=true<3>
quarkus.kubernetes.deployment-target=openshift<4>
quarkus.openshift.expose=true<5>
quarkus.openshift.labels.app.openshift.io/runtime=quarkus<6>
----

<1> この単純な例では自己署名証明書を使用しているので、これは単に拡張モジュールに信頼するように言っているだけです。
<2> コンテナイメージを構築するように拡張機能に指示します。
<3> コンテナイメージを構築した後、拡張機能をOpenShiftにデプロイするように指示します。
<4> コンテナをビルドした後にOpenShiftリソース（`DeploymentConfig`や`Service`など）を生成・作成するように拡張機能に指示します。
<5> OpenShiftの `Route` を生成するように拡張機能に指示します。
<6> OpenShift Developer Toplogyの表示時にアプリに見栄えの良いアイコンを追加。

では、アプリケーション自体をデプロイしてみましょう。以下のコマンドを実行すると、OpenShift拡張機能を使用してビルドとデプロイが行われます :

[source,sh,role="copypaste"]
----
mvn clean package -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/cart-service
----

出力は `BUILD SUCCESS` で終わるべきである。

最後に、実際にロールアウトが完了したことを確認してください :

[source,sh,role="copypaste"]
----
oc rollout status -w dc/cart
----

コマンドが *replication controller _cart-1_ successfully rolled out* を報告するのを待ってから続行してください。

そして、アイテムには適切なアイコンでラベルを貼ります :

[source,sh,role="copypaste"]
----
oc label dc/cart app.kubernetes.io/part-of=cart app.openshift.io/runtime=quarkus --overwrite && \
oc label dc/datagrid-service app.kubernetes.io/part-of=cart app.openshift.io/runtime=datagrid --overwrite && \
oc annotate dc/cart app.openshift.io/connects-to=catalog,datagrid-service --overwrite && \
oc annotate dc/cart app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

最後に、実際にロールアウトが完了していることを確認します。カタログは {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] にアクセスして、青い丸が表示されていることを確認してください!

image::cart-topology.png[catalog, 700]

http://cart-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN }}/swagger-ui[Cart Swagger UI^] にアクセスします :

image::cart-swagger-ui.png[cart, 700]

メソッドの後にドキュメントがあることに注意してください、これは他のサービス開発者が各サービスメソッドで何をしようとしているかを知るための優れた方法です。メソッドを呼び出してみて、サービスからの出力を見ることができます。したがって、迅速にテストするための優れた方法でもあります。

=== 4. オーダーサービスの開発と展開

オーダーサービスは、お客様がショッピングカートで商品をチェックアウトする際に、すべての注文を管理します。注文サービスが *Quarkus* Javaランタイムで *MongoDB* データベースを使用するための REST サービスを取得する方法を簡単に説明します。_CodeReady Workspaces_ Web IDE の _/projects_ に移動し、*order-service* ディレクトリを展開します。

image::codeready-workspace-order-project.png[order, 700]

_Quarkus_ で構築されたアプリケーションは非常にシンプルです : ユーザは _RESTful API_ を使用してリストに要素を追加することができ、リストは更新されます。クライアントとサーバー間のすべての情報は *JSON* としてフォーマットされています。要素は _MongoDB_ に保存されます。

CodeReady Workspaces Terminal 経由で Quarkus Extensions を使用してMavenの依存関係を追加するには、以下のコマンドを実行します :

[source,sh,role="copypaste"]
----
mvn -q quarkus:add-extension -Dextensions="resteasy-jsonb,mongodb-client" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/order-service
----

アウトプットを見ることができます :

[source,console]
----
✅ Extension io.quarkus:quarkus-resteasy-jsonb has been installed
✅ Extension io.quarkus:quarkus-mongodb-client has been installed
----

このコマンドは、RESTEasy/JAX-RS、JSON-B、MongoDBクライアント拡張機能をインポートする Maven 構造体を生成します。この後、quarkus-mongodb-client 拡張機能が *pom.xml* に追加されました。

image::order-pom-dependency.png[order, 700]

JSON RESTサービスを使って注文サービスを作る前に、`src/main/java/com/redhat/cloudnative/` の `Order` Beanを以下のように見てみましょう :

image::order_bean.png[order, 700]

派手なものは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことは、*JSONシリアライズレイヤー* によって要求されているということです。

次に `com.redhat.cloudnative.OrderService` クラスを開きます。これがアプリケーションのビジネスレイヤーとなり、MongoDB データベースからの注文を _保存/ロード_ します。各マーカーに以下の java コードを追加します。

`// TODO: Inject MongoClient here` マーカー :

[source,java,role="copypaste"]
----
    @Inject MongoClient mongoClient;
----

次に、list() メソッド内のマーカー `// TODO: Add a while loop to make an order lists using MongoCursor here` に次のコードを追加します。

[source,java,role="copypaste"]
----
        MongoCursor<Document> cursor = getCollection().find().iterator();

        try {
            while (cursor.hasNext()) {
                Document document = cursor.next();
                Order order = new Order();
                order.setOrderId(document.getString("orderId"));
                order.setName(document.getString("name"));
                order.setTotal(document.getString("total"));
                order.setCcNumber(document.getString("ccNumber"));
                order.setCcExp(document.getString("ccExp"));
                order.setBillingAddress(document.getString("billingAddress"));
                order.setStatus(document.getString("status"));
                list.add(order);
            }
        } finally {
            cursor.close();
        }
----

`add(Order order)` のマーカー `// TODO: Add to create a Document based order here` に次のコードを追加します :

[source,java,role="copypaste"]
----
        Document document = new Document()
                .append("orderId", order.getOrderId())
                .append("name", order.getName())
                .append("total", order.getTotal())
                .append("ccNumber", order.getCcNumber())
                .append("ccExp", order.getCcExp())
                .append("billingAddress", order.getBillingAddress())
                .append("status", order.getStatus());
        getCollection().insertOne(document);
----

これらふたつのメソッドは、MongoDB で使うのに適した `Document` オブジェクトと、ビジネスバリューオブジェクトである `Order` ドキュメントを変換します。

次に、`com.redhat.cloudnative.OrderResource` クラスを各マーカーで以下のように編集します :

`// TODO: Add JAX-RS annotations here` マーカー:

[source,java,role="copypaste"]
----
@Path("/api/orders")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
----

`// TODO: Inject OrderService here` マーカー :

[source,java,role="copypaste"]
----
    @Inject OrderService orderService;
----

`// TODO: Add list(), add(), updateStatus() methods here` マーカー:

[source,java,role="copypaste"]
----
    @GET
    public List<Order> list() {
        return orderService.list();
    }

    @POST
    public List<Order> add(Order order) {
        orderService.add(order);
        return list();
    }

    @GET
    @Path("/{orderId}/{status}")
    public List<Order> updateStatus(@PathParam("orderId") String orderId, @PathParam("status") String status) {
        orderService.updateStatus(orderId, status);
        return list();
    }
----

実装はとても簡単で、*JAX-RS アノテーション* を使用してエンドポイントを定義し、_OrderService_ を使用して新しい注文をリストアップ/追加するだけです。

設定する主なプロパティは*MongoDB*にアクセスするためのURLで、ほとんどすべての設定は接続URIに含めることができます。というわけで、 https://docs.mongodb.com/manual/reference/connection-string/[MongoDB documentation^] で詳細を確認することができます。

`src/main/resources/` で `application.properties` を開き、`# TODO: Add for MongoDB configuration` マーカーに以下の設定を追加します :

[source,sh,role="copypaste"]
----
quarkus.mongodb.connection-string = mongodb://order-database:27017
----

Bson *Codec* を使うことで、MongoDB クライアントが MongoDB *Document* からドメインオブジェクへの変換またはその逆を自動的に行います。

まず、Bson Codec を作成して、エンティティを MongoDB Document との間でどのように変換するかを Bson に伝える必要があります。ここでは、オブジェクトがデータベースから取得できる(MongoDB の識別子を持っている)ので、_CollectibleCodec_ を使用しています。詳細は https://mongodb.github.io/mongo-java-driver/3.10/bson/codecs[codecdocumentation^] を参照してください。

以下のように `com.redhat.cloudnative.codec.OrderCodec` クラスを編集します :

`// TODO: Add Encode & Decode contexts here` マーカー:

[source,java,role="copypaste"]
----
    @Override
    public void encode(BsonWriter writer, Order Order, EncoderContext encoderContext) {
        Document doc = new Document();
        doc.put("orderId", Order.getOrderId());
        doc.put("name", Order.getName());
        doc.put("total", Order.getTotal());
        doc.put("ccNumber", Order.getCcNumber());
        doc.put("ccExp", Order.getCcExp());
        doc.put("billingAddress", Order.getBillingAddress());
        doc.put("status", Order.getStatus());
        documentCodec.encode(writer, doc, encoderContext);
    }

    @Override
    public Class<Order> getEncoderClass() {
        return Order.class;
    }

    @Override
    public Order generateIdIfAbsentFromDocument(Order document) {
        if (!documentHasId(document)) {
            document.setOrderId(UUID.randomUUID().toString());
        }
        return document;
    }

    @Override
    public boolean documentHasId(Order document) {
        return document.getOrderId() != null;
    }

    @Override
    public BsonValue getDocumentId(Order document) {
        return new BsonString(document.getOrderId());
    }

    @Override
    public Order decode(BsonReader reader, DecoderContext decoderContext) {
        Document document = documentCodec.decode(reader, decoderContext);
        Order order = new Order();
        if (document.getString("orderId") != null) {
            order.setOrderId(document.getString("orderId"));
        }
        order.setName(document.getString("name"));
        order.setTotal(document.getString("total"));
        order.setCcNumber(document.getString("ccNumber"));
        order.setCcExp(document.getString("ccExp"));
        order.setBillingAddress(document.getString("billingAddress"));
        order.setStatus(document.getString("status"));
        return order;
    }
----

次に、この `Codec` を Order クラスにリンクするための `CodecProvider` を作成する必要があります。

以下のように `com.redhat.cloudnative.codec.OrderCodecProvider` クラスを編集します :

`// TODO: Add Codec get method here` マーカー :

[source,java,role="copypaste"]
----
    @Override
    public <T> Codec<T> get(Class<T> clazz, CodecRegistry registry) {
        if (clazz == Order.class) {
            return (Codec<T>) new OrderCodec();
        }
        return null;
    }
----

_Quarkus_ は、_CodecProvider_ を登録してくれます。

最後に、データベースから _MongoCollection_ を取得する際には、Document クラスの代わりに Order クラスを直接使用することができます。コーデックは自動的にドキュメントをオーダークラスにマッピングします。

以下のように `com.redhat.cloudnative.CodecOrderService` クラスを編集します :

`// TODO: Add MongoCollection method here` マーカー:

[source,java,role="copypaste"]
----
    private MongoCollection<Order> getCollection(){
        return mongoClient.getDatabase("order").getCollection("order", Order.class);
    }
----

以下の `oc` コマンドを実行して、CodeReady Workspaces Terminal 経由で `MongoDB` を OpenShift にデプロイします :

[source,sh,role="copypaste"]
----
oc new-app --as-deployment-config -n {{ USER_ID }}-cloudnativeapps --docker-image mongo:4.0 --name=order-database
----

では、アプリケーション自体をデプロイしてみましょう。以下のコマンドを実行すると、OpenShift拡張機能を使用してビルドとデプロイが行われます :

[source,sh,role="copypaste"]
----
mvn clean package -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/order-service
----

出力は `BUILD SUCCESS` で終わっているはずです。

最後に、実際にロールアウトが完了したことを確認してください :

[source,sh,role="copypaste"]
----
oc rollout status -w dc/order
----

続ける前に、そのコマンドが *replication controller _order-1_ successfully rolled out* を報告するのを待ちます。

そして、適切なアイコンでアイテムにラベルを付けます :

[source,sh,role="copypaste"]
----
oc label dc/order app.kubernetes.io/part-of=order --overwrite && \
oc label dc/order-database app.kubernetes.io/part-of=order app.openshift.io/runtime=mongodb --overwrite && \
oc annotate dc/order app.openshift.io/connects-to=order-database --overwrite && \
oc annotate dc/order app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

最後に、実際にロールアウトが完了していることを確認します。オーダーは {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] にアクセスしてください。青い丸が表示されていることを確認してください!

image::order-topology.png[order, 700]

そして、 http://order-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN }}/api/orders[Orders^] にアクセスします。まだショッピングアイテムを追加していないので、空の結果が表示されます :

[source,sh]
----
[]
----

これはターミナルでこのコマンドを使って `curl` で確認することもできます:

[source,sh,role="copypaste"]
----
curl -s http://order-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN }}/api/orders | jq
----

空の配列 `[]` を返します。

=== 5. WEB-UI サービス のデプロイ

私たちの Web UI は、 https://angularjs.org/[AngularJS^] と http://patternfly.org/[PatternFly^] をベースにしたフロントエンドを https://access.redhat.com/documentation/en/openshift-container-platform/3.3/paged/using-images/chapter-2-source-to-image-s2i[Node.js] コンテナで実行しています。 https://www.redhat.com/en/products/runtimes[Red Hat Runtimes^] には、クラウドネイティブ開発に使用される他のランタイムとともに *Node.js* のサポートが含まれています。

フロントエンドサービスがどのように動作し、Node.js ランタイム上に構築されているかを簡単に説明しましょう。CodeReady Workspaces の _/projects_ に移動し、`coolstore-ui` ディレクトリを展開します。

image::codeready-workspace-coolstore-ui.png[coolstore-ui, 700]

上記のように、カートや catatlog 、注文サービスなど、特定のクラウドネイティブサービスの JavaScript が表示されます。

では、Node.js プロジェクトを OpenShift にデプロイするために使えるプログラマブル API である https://www.npmjs.com/package/nodeshift[Nodeshift] コマンドラインツールを使って、プレゼンテーションレイヤーを OpenShift クラスタにデプロイしていきます。

CodeReady Workspaces ターミナルから Nodeshift をインストールします :

[source,sh,role="copypaste"]
----
cd $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/coolstore-ui && npm install --save-dev nodeshift
----

[NOTE]
====
既知の脆弱性に関する _npm_ からの警告が表示されるかもしれません。_npm_ のエコシステムは巨大で、私たちのアプリには多くの依存関係があり、常に新しい問題を発見しています。実際の運用システムではこれらに注意を払う必要がありますが、このワークショップでは無視することができます。
====

次に、CodeReady Workspaces ターミナルで `Nodeshift` を使って _coolstore-ui_ サービスをデプロイします。デプロイが完了するまでに1分ほどかかります :

[source,sh,role="copypaste"]
----
npm run nodeshift && oc expose svc/coolstore-ui && \
oc label dc/coolstore-ui app.kubernetes.io/part-of=coolstore --overwrite && \
oc annotate dc/coolstore-ui app.openshift.io/connects-to=order-cart,catalog,inventory,order --overwrite && \
oc annotate dc/coolstore-ui app.openshift.io/vcs-uri=https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m4-labs.git --overwrite && \
oc annotate dc/coolstore-ui app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] に戻って、デプロイが完了していることを確認します(紺色の丸) :

image::coolstore-ui_topology.png[coolstore-ui, 700]

そして、 http://coolstore-ui-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN }}[Red Hat Cool Store^] にアクセスして、期待されている製品や在庫を確保します。

image::web-ui-landing.png[coolstore-ui, 700]

これにより、フロントエンドがバックエンドに適切に接続されていることが確認され、データグリッドのデプロイメントに適切に接続されていることが確認されます。

=== 概要

このシナリオでは、5つのマイクロサービスを開発してデプロイし、それぞれが REST API を持ち、他のマイクロサービスと通信するようにしました。また、Quarkus、Spring Boot、Node.js などの様々なアプリケーションランタイムを使用して、アプリケーションのコンパイル、パッケージ化、コンテナ化を行いましたが、これは高度な Cloud Native アーキテクチャの重要な機能です。

OpenShift クラスタ上に複数のデータソースを持つ Cloud Native アプリケーションを展開するために、Quarkus は複数のデータソースを接続し、PostgreSQL や MongoDB などのデータソースへの参照をコードで取得する簡単な方法を提供しています。

最終的には、ショッピングカートサービスを *Red Hat Data Grid* と統合することで、エンドユーザー(顧客)の満足度を高めることで、ショッピングカートサービスの _トランザクションパフォーマンス_ を最適化しました。たった一人のユーザー(あなた)だけではわからないかもしれませんが、規模が大きくなれば、これらのコンポーネントによってリライする能力とビジネスパフォーマンスを確保することができます。*おめでとうございます！*
