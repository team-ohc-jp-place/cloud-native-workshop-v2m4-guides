== Cloud Native アプリケーションアーキテクチャ
:experimental:

リアクティブなアプリケーション、インプライベーティブなアプリケーション、イベントドリブンなアプリケーション、ポリグロットなアプリケーションを開発することは、すべて現代のアプリケーションアーキテクチャの要件です。Red Hat OpenStack Platform や Red Hat OpenShift などのクラウドインフラストラクチャやコンテナ Kubernetes ソリューションは、分散環境のための堅牢なインフラ基盤を提供していますが、同様のシームレスなアプリケーションサービスでは、このようなインフラをフルに活用したアプリケーションを構築する必要があります。

さらに、アプリケーションは、デジタル経済の中で繁栄するために、ハイブリッドおよびマルチクラウドアーキテクチャを必要としています。統一された Cloud Native のアプリケーション環境は、完全にまとまった開発プラットフォームで生産性の向上とイノベーションを可能にするため、開発者にとって不可欠なものとなっています。アプリケーション環境は、急速な変化とスケーラビリティ、アジリティ、信頼性に対する高い要求のため、運用にとっても同様に重要です。

このモジュールでは、DevOps / Cloud Native プラットフォーム上でコンテナ化されたアプリケーションをスケールとスピードで実行するために、どのような Cloud Native アーキテクチャを設計する必要があるのかを学びます。その後、 https://www.redhat.com/en/technologies/cloud-computing/openshift/application-runtimes[Red Hat Runtimes] 、 https://developers.redhat.com/products/codeready-workspaces/overview[Red Hat CodeReady Workspaces^]、 https://www.redhat.com/en/technologies/cloud-computing/openshift[Red Hat OpenShift Container Platform] を使用して、高パフォーマンスキャッシュ、イベントドリブン/リアクティブ、サーバーレスなどのアーキテクチャパターンに基づいたクラウドネイティブアプリケーションの開発も行います。

=== Cloud Native アプリケーションアーキテクチャの能力とは?

Cloud Native アプリケーションアーキテクチャの利点は、開発とデプロイのスピード、柔軟性、品質、信頼性を可能にします。さらに重要なのは、開発者は、急な学習曲線なしで最新のオープンソース技術とアプリケーションを統合することができます。Cloud Native アプリケーションを構築してアーキテクチャを構築する方法は数多くありますが、以下に検討すべき素晴らしい要素をいくつか挙げます :

* *Runtimes* - Java、Node.js、Go、Python、Ruby などのランタイムを意味するランタイム、つまりコンテナファーストもしくは Kubernetes Native 言語で記述されたもの
* *Security* - マルチクラウド、ハイブリッドクラウドのアプリケーション環境でアプリケーションをデプロイして維持する場合、セキュリティが最も重要になり、環境の一部となる必要があります。
* *可観測性* - クラウド上でアプリケーションとその動作を観察できること。リアルタイムのメトリクスを提供できるツール、使用に関するより多くの情報を提供できるツール(例 : Prometheus、Grafana、Kialiなど)。
* *効率性* -  小さなメモリフットプリント、小さなアーティファクトサイズ、高速な起動時間に焦点を当て、ハイブリッド/マルチクラウドプラットフォーム上でポータブルなアプリケーションを作成します。主に、最小限のコンピューティング リソースを消費しながら迅速なスケーリングを行うことで、本番環境で期待されるスパイスを活用します。
* *相互運用性* - Infinispan、MicroProfile、Hibernate、Apache Kafka、Jaeger、Prometheusなどの最新のオープンソース技術と Cloud Native アプリを簡単に統合し、標準ランタイムアーキテクチャを構築することができます。
* *DevOps/DevSecOps* - 最小限の実行可能な製品（MVP）に沿って、開発、テストの自動化、およびコラボレーションとともに、ツールの一部としてのセキュリティを備えた、本番環境への継続的なデプロイメントのために設計されています。

=== Red Hat で Cloud Native アプリケーションとアーキテクチャを構築するには？

_Red Hat Runtimes_ は、Cloud Native アプリケーションを開発・保守するための推奨製品、ツール、コンポーネントのセットです。マイクロサービスなどの高度に分散されたクラウド環境向けの軽量なランタイムとフレームワークを提供し、高速なデータアクセスを可能にするインメモリキャッシングや、既存のアプリケーションをサポートする迅速なデータ転送を可能にするメッセージング機能を備えています。

image::rhar.png[Red Hat Runtimes Prducts and Components, 900]

Red Hat Runtimes は、既存のアプリケーションを維持することを目的としている場合でも、新しいアプリケーションを作成する場合でも、最新のアプリケーションを提供するための統合された最適化された製品とコンポーネントを提供します。Applications Runtimes は、開発者がマイクロサービスアーキテクチャでアプリケーションをコンテナ化したり、インメモリデータキャッシングによるデータアクセス速度の向上、メッセージングによるアプリケーションパフォーマンスの向上、最新の開発パターンやテクノロジーを使用した Cloud Native アプリケーション開発の適応などを可能にします。

さらに、ラボでは、ほとんどのアプリケーションに Quarkus を使用しています。Quarkus の詳細については、続きをお読みください。

==== Quarkus とは?

image::quarkus-logo.png[quarkus-logo, 900]

何年もの間、クライアント・サーバ・アーキテクチャは、アプリケーションを構築するための事実上の標準でした。しかし、大きな変化が起こりました。1つのモデルがすべての時代を支配していた時代は終わりました。新しい範囲のアプリケーションとアーキテクチャのスタイルが登場し、コードの書き方やアプリケーションの展開と実行の仕方に影響を与えています。HTTP マイクロサービス、リアクティブアプリケーション、メッセージ駆動型マイクロサービス、サーバーレスは、現在のシステムの中心的な役割を果たしています。

https://Quarkus.io/[Quarkus] 、Cloud Native 、マイクロサービス、サーバーレスJavaアプリケーションを構築するための4つの大きなメリットを提供しています :

* _開発者の喜び_ - 統一された設定による開発者の喜びを最適化するための凝集したプラットフォーム、瞬時にライブリロードが可能なゼロコンフィグレーション、一般的な使用法のための 80% の合理化されたコードと柔軟な 20% のコード、そして手間のかからないネイティブ実行ファイル生成を提供します。
* _インペラティブとリアクティブの統合_ - 同一アプリケーション内で Reactive と imperative の両方の開発のために EventBus または Vertx コンテキストを注入します。
* _Functions as a Service とサーバーレス_ - 高速な起動と低いメモリ使用率。Quarkus を使用すると、プログラミング言語を変更することなく、この新しい世界を受け入れることができます。
* _ベストオブブリードなフレームワークとスタンダード_ - CodeReady Workspaces、Vert.x、Hibernate、RESTEasy、Apache Camel、MicroProfile、Netty、Kubernetes、OpenShift、Jaeger、Prometheus、Apacke Kafka、Infinispanなど。

*Red Hat* Quarkusのサポートと保守が完全にサポートされた https://access.redhat.com/products/quarkus[Red Hat Build of Quarkus(RHBQ)^] を提供しています。このワークショップでは、Quarkus を使用して Kubernetes ネイティブのマイクロサービスを開発し、OpenShift にデプロイします。Quarkus は、 https://www.redhat.com/en/products/runtimes[Red Hat Runtimes^] に含まれるランタイムの一つです。 https://access.redhat.com/documentation/en-us/red_hat_build_of_quarkus[RHBQの詳細はこちら^]。

=== ラボの準備

[NOTE]
====
他のラボを既に終えている方は、CodeReady 環境に慣れていると思いますので、*Import Project* セクションまでスキップしてください。
====

==== 本日最初のモジュールの場合

使用するのは、 https://www.eclipse.org/che/[Eclipe Che^] をベースにしたオンライン IDE である Red Hat CodeReady Workspaces を使用します。*ファイルへの変更は数秒ごとに自動保存されます* ので、明示的に変更を保存する必要はありません。

開始するには、 {{ ECLIPSE_CHE_URL }}[CodeReady Workspacesインスタンスにアクセス^] し、割り当てられたユーザー名とパスワード(例: `{{ USER_ID }}/{{ CHE_USER_PASSWORD }}` )を使用してログインします :

image::che-login.png[cdw, 700]

ログインすると、個人のダッシュボードが表示されます。以下のように、左側にあるあらかじめ作成されたワークスペースの名前をクリックします（割り当てられた番号によって名前が異なります）。また、中央のワークスペースの名前をクリックし、画面右上の _Open_ と書かれた緑色の {{ USER_ID }}-namespace をクリックします。

image::che-landing.png[cdw, 700]

1～2分後、ワークスペースに配置されます :

image::che-workspace.png[cdw, 900]

このIDEは、Eclipse Cheをベースにしています(これは、MicroSoft VS Code editor をベースにしています)。

プロジェクトエクスプローラ、検索、バージョン管理(Gitなど)、デバッグ、その他のプラグインの間を移動するためのアイコンが左に表示されています。 このワークショップではこれらを使います。自由にクリックして何ができるか見てみてください :

image::crw-icons.png[cdw, 400]

[NOTE]
====
奇妙な動作をしたり、ブラウザが表示された場合は、ブラウザタブを再読み込みして表示を更新するだけです。
====

CodeReady Workspaces の多くの機能は *Commands* からアクセスできます。いくつかのコマンドは、ホームページにリンクが張られています（例： _New File..._ 、_Git Clone..._ など）。

メニューに表示されていないコマンドを実行したい場合は、kbd:[F1] を押してコマンドウィンドウを開くか、従来の kbd:[Control+SHIFT+P]（Mac OS Xでは kbd:[Command+SHIFT+P] ）を押してコマンドを実行することができます。

==== プロジェクトのインポート

最初のプロジェクトをインポートしてみましょう。*Git Clone..* をクリックします（または kbd:[F1]と入力して 'git' と入力し、自動補完された _Git Clone.._ をクリックします）。

image::che-workspace-gitclone.png[cdw, 900]

プロンプトの指示に従って、**リポジトリURL** に次の値を使用してください。*FireFox* を使用している場合、最後に余分なスペースを貼り付けてしまう可能性があるので、貼り付けた後はバックスペースを押してください :

[source,none,role="copypaste"]
----
https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m4-labs.git
----

image::crw-clone-repo.png[crw,900]

プロジェクトはワークスペースにインポートされ、プロジェクトエクスプローラに表示されます:

image::crw-clone-explorer.png[crw,900]

==== 重要: 適切な Git ブランチをチェックアウト

プロジェクトファイルの正しいバージョンを使用していることを確認するには、CodeReadyターミナルでこのコマンドを実行してください :

[source,sh,role="copypaste"]
----
cd $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs && git checkout ocp-4.5
----

=== 他プロジェクトの削除

今日他のモジュール(例えば `cloud-native-workshop-v2m1-lab` )を完了した場合は、エクスプローラでプロジェクト名を右クリックして *Delete* を選択し、警告を受け入れてワークスペースからそれらを削除してください。このラボのためにインポートした新しいプロジェクトを削除しないように注意してください。

image::remove-workspace.png[remove, 700]

[NOTE]
====
CodeReady ワークスペースのターミナルウィンドウ。Developer ワークスペースで実行しているコンテナのいずれかのターミナルウィンドウを開くことができます。これらのラボの残りの部分については、ターミナルでコマンドを実行する必要がある場合はいつでも、右側の *>_ New Terminal* コマンドを使用することができます :
====

image::codeready-workspace-terminal.png[codeready-workspace-terminal, 700]
